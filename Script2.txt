# Download and extract Blender 3.6
!wget https://download.blender.org/release/Blender3.6/blender-3.6.0-linux-x64.tar.xz
!tar -xf blender-3.6.0-linux-x64.tar.xz
!mv blender-3.6.0-linux-x64 /usr/local/blender-3.6

# Symlink Blender binary so we can call it directly
!ln -s /usr/local/blender-3.6/blender /usr/local/bin/blender

# Check version to verify
!blender --version

# STEP 2: Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

%%writefile sphero_animation.py
# PASTE FULL SCRIPT HERE
import bpy
import os
os.makedirs("/content/drive/MyDrive/SpheroRender", exist_ok=True)
import math
import random
from mathutils import Vector
import csv

scene = bpy.context.scene
scene.render.fps = 60
scene.frame_start = 1
scene.frame_end = 120

bpy.context.scene.frame_set(scene.frame_start)

# Clear existing objects
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()

# Set up rendering
scene = bpy.context.scene
scene.render.engine = 'BLENDER_EEVEE' # Changed to Eevee
scene.eevee.taa_samples = 64       # Temporal Anti-Aliasing samples
scene.render.resolution_x = 1920
scene.render.resolution_y = 1080
scene.render.fps = 60


# Create ground plane
bpy.ops.mesh.primitive_plane_add(size=50, location=(0, 0, 0))
ground = bpy.context.active_object
ground.name = "Ground"

# Add material to ground
mat = bpy.data.materials.new(name="GroundMaterial")
mat.use_nodes = True
nodes = mat.node_tree.nodes
bsdf = nodes.get("Principled BSDF")
bsdf.inputs["Base Color"].default_value = (0.2, 0.2, 0.2, 1.0)
ground.data.materials.append(mat)

# Create wall
bpy.ops.mesh.primitive_cube_add(size=1, location=(0, 13, 0.25))
wall = bpy.context.active_object
wall.name = "Wall"
wall.scale = (20, 0.5, 4)
wall.location = (0, 15, 2)

# Add material to wall
mat = bpy.data.materials.new(name="WallMaterial")
mat.use_nodes = True
nodes = mat.node_tree.nodes
bsdf = nodes.get("Principled BSDF")
bsdf.inputs["Base Color"].default_value = (0.8, 0.8, 0.8, 1.0)
wall.data.materials.append(mat)

# Create energy absorption barrier
def create_barrier():
    # Base structure
    bpy.ops.mesh.primitive_cube_add(size=1, location=(0, 13, 1))
    base = bpy.context.active_object
    base.name = "BarrierBase"
    base.scale = (15, 1, 0.5)

    # Add material to base
    mat = bpy.data.materials.new(name="BaseMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    bsdf = nodes.get("Principled BSDF")
    bsdf.inputs["Base Color"].default_value = (0.5, 0.3, 0.1, 1.0)
    base.data.materials.append(mat)

    # High-density foam backing
    bpy.ops.mesh.primitive_cube_add(size=1, location=(0, 13.6, 0.85))
    backing = bpy.context.active_object
    backing.name = "FoamBacking"
    backing.scale = (14, 0.5, 1.2)
    backing.location = (0, 13.6, 0.85)

    # Add material to backing
    mat = bpy.data.materials.new(name="BackingMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    bsdf = nodes.get("Principled BSDF")
    bsdf.inputs["Base Color"].default_value = (0.2, 0.4, 0.6, 1.0)
    bsdf.inputs["Roughness"].default_value = 0.9
    backing.data.materials.append(mat)

    # Springs array
    springs = []
    num_springs = 8
    spring_width = 12 / num_springs

    for i in range(num_springs):
        x_pos = -6 + i * spring_width + spring_width/2
        bpy.ops.mesh.primitive_cylinder_add(
            vertices=16,
            radius=0.2,
            depth=0.8,
            location=(x_pos, 14.1, 1.6)
        )
        spring = bpy.context.active_object
        spring.name = f"Spring_{i}"

        # Add spring material
        mat = bpy.data.materials.new(name=f"SpringMaterial_{i}")
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        bsdf = nodes.get("Principled BSDF")
        bsdf.inputs["Base Color"].default_value = (0.7, 0.7, 0.7, 1.0)
        bsdf.inputs["Metallic"].default_value = 0.9
        spring.data.materials.append(mat)

        # Create spring coil geometry
        bpy.ops.curve.primitive_bezier_circle_add(radius=0.2, location=(x_pos, 14.1, 1.6))
        circle = bpy.context.active_object

        bpy.ops.curve.primitive_bezier_curve_add(location=(x_pos, 14.1, 1.6))
        curve = bpy.context.active_object
        curve.data.dimensions = '3D'
        curve.data.resolution_u = 64
        curve.data.bevel_object = circle

        # Create spring coil shape
        bezier_points = curve.data.splines[0].bezier_points
        bezier_points.add(10-1)  # Add points (minus the one that's already there)

        coil_height = 0.8
        coil_radius = 0.2
        coil_turns = 4

        for j in range(len(bezier_points)):
            t = j / (len(bezier_points) - 1)
            angle = t * coil_turns * 2 * math.pi
            z = t * coil_height
            x = math.cos(angle) * coil_radius
            y = math.sin(angle) * coil_radius

            bezier_points[j].co = (x, y, z)
            bezier_points[j].handle_left_type = 'AUTO'
            bezier_points[j].handle_right_type = 'AUTO'

        # Apply material to spring coil
        curve.data.materials.append(mat)
        springs.append(curve)

        # Remove the cylinder (was just for placement reference)
        bpy.data.objects.remove(spring)
        bpy.data.objects.remove(circle)

    # Impact surface (curved)
    bpy.ops.mesh.primitive_cube_add(size=1, location=(0, 14.7, 1.6))
    impact = bpy.context.active_object
    impact.name = "ImpactSurface"
    impact.scale = (14, 0.3, 1.2)

    # Bend the impact surface to make it concave
    # Add subdiv modifier for smooth bending
    subdiv = impact.modifiers.new(name="Subdivision", type='SUBSURF')
    subdiv.levels = 3
    subdiv.render_levels = 3

    # Add simple deform modifier for bending
    bend = impact.modifiers.new(name="Bend", type='SIMPLE_DEFORM')
    bend.deform_method = 'BEND'
    bend.deform_axis = 'Y'
    bend.angle = -0.5

    # Apply modifiers
    bpy.context.view_layer.objects.active = impact
    bpy.ops.object.modifier_apply(modifier="Subdivision")
    bpy.ops.object.modifier_apply(modifier="Bend")

    # Add material to impact surface
    mat = bpy.data.materials.new(name="ImpactMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    bsdf = nodes.get("Principled BSDF")
    bsdf.inputs["Base Color"].default_value = (0.1, 0.2, 0.7, 1.0)
    bsdf.inputs["Roughness"].default_value = 0.3
    impact.data.materials.append(mat)

    return base, backing, springs, impact

barrier_base, barrier_backing, barrier_springs, barrier_impact = create_barrier()

# Create Sphero Bolt
bpy.ops.mesh.primitive_uv_sphere_add(radius=0.75, location=(-5, 5, 0.75))
sphero = bpy.context.active_object
sphero.name = "Sphero"

# Add material to Sphero
import bpy

# Add material to Sphero
mat = bpy.data.materials.new(name="SpheroMaterial")
mat.use_nodes = True
nodes = mat.node_tree.nodes

# Try to get the Principled BSDF node
bsdf = nodes.get("Principled BSDF")

if bsdf:
    # Set properties on the BSDF if it exists
    bsdf.inputs["Base Color"].default_value = (0.9, 0.9, 0.9, 1.0)
    bsdf.inputs["Metallic"].default_value = 0.2
    bsdf.inputs["Roughness"].default_value = 0.2

    # Check if 'Clearcoat' exists before trying to access it
    if "Clearcoat" in bsdf.inputs:
        bsdf.inputs["Clearcoat"].default_value = 1.0
    else:
        print("Clearcoat input not available in the Principled BSDF node.")
else:
    print("Principled BSDF node not found.")

# Apply the material to the Sphero object
sphero = bpy.context.active_object  # Ensure that the Sphero object is selected
if sphero:
    sphero.data.materials.append(mat)
else:
    print("No active object selected.")


# Set up lighting
def create_lighting():
    # Key light
    bpy.ops.object.light_add(type='AREA', radius=5, location=(10, -10, 15))
    key_light = bpy.context.active_object
    key_light.name = "KeyLight"
    key_light.data.energy = 500
    key_light.data.size = 5

    # Fill light
    bpy.ops.object.light_add(type='AREA', radius=5, location=(-10, -10, 10))
    fill_light = bpy.context.active_object
    fill_light.name = "FillLight"
    fill_light.data.energy = 300
    fill_light.data.size = 7

    # Rim light
    bpy.ops.object.light_add(type='AREA', radius=3, location=(0, -15, 8))
    rim_light = bpy.context.active_object
    rim_light.name = "RimLight"
    rim_light.data.energy = 400
    rim_light.data.size = 3

    # Environment lighting with HDRI
    world = bpy.context.scene.world
    if not world:
        world = bpy.data.worlds.new("World")
        bpy.context.scene.world = world

    world.use_nodes = True
    node_tree = world.node_tree

    # Clear existing nodes
    for node in node_tree.nodes:
        node_tree.nodes.remove(node)

    # Create new nodes
    node_background = node_tree.nodes.new(type='ShaderNodeBackground')
    node_environment = node_tree.nodes.new(type='ShaderNodeTexEnvironment')
    node_output = node_tree.nodes.new(type='ShaderNodeOutputWorld')

    # Connect nodes
    node_tree.links.new(node_environment.outputs["Color"], node_background.inputs["Color"])
    node_tree.links.new(node_background.outputs["Background"], node_output.inputs["Surface"])

    # Position nodes
    node_environment.location = (-300, 0)
    node_background.location = (0, 0)
    node_output.location = (300, 0)

    # Create a simple procedural environment
    mapping = node_tree.nodes.new(type='ShaderNodeMapping')
    tex_coord = node_tree.nodes.new(type='ShaderNodeTexCoord')
    gradient = node_tree.nodes.new(type='ShaderNodeTexGradient')

    node_tree.links.new(tex_coord.outputs["Generated"], mapping.inputs["Vector"])
    node_tree.links.new(mapping.outputs["Vector"], gradient.inputs["Vector"])
    node_tree.links.new(gradient.outputs["Color"], node_background.inputs["Color"])

    # Set gradient colors for a nice studio look
    color_ramp = node_tree.nodes.new(type='ShaderNodeValToRGB')
    color_ramp.color_ramp.elements[0].color = (0.05, 0.05, 0.1, 1.0)
    color_ramp.color_ramp.elements[1].color = (0.2, 0.3, 0.4, 1.0)

    node_tree.links.new(gradient.outputs["Color"], color_ramp.inputs["Fac"])
    node_tree.links.new(color_ramp.outputs["Color"], node_background.inputs["Color"])

    return key_light, fill_light, rim_light

key_light, fill_light, rim_light = create_lighting()

# Set up camera
bpy.ops.object.camera_add(location=(15, -15, 6), rotation=(math.radians(70), 0, math.radians(135)))
camera = bpy.context.active_object
camera.name = "Camera"
bpy.context.scene.camera = camera

# Track camera to look at sphero
track_to = camera.constraints.new(type='TRACK_TO')
track_to.target = sphero
track_to.track_axis = 'TRACK_NEGATIVE_Z'
track_to.up_axis = 'UP_Y'

# Add rigidbody to sphero
bpy.context.view_layer.objects.active = sphero
bpy.ops.rigidbody.object_add()
sphero.rigid_body.mass = 2.0
sphero.rigid_body.restitution = 0.8
sphero.rigid_body.friction = 0.3
sphero.rigid_body.collision_shape = 'SPHERE'
# Explicitly set initial linear velocity to zero
sphero.rigid_body.kinematic = False

# Linear animation for Sphero - moving straight toward the wall
sphero.rigid_body.kinematic = False
bpy.ops.object.effector_add(type='FORCE',
location=(-5, 5, 0.75))
push_force = bpy.context.active_object
push_force.name = "SpheroPushForce"
push_force.field.strength = 20
push_force.field.falloff_type = 'SPHERE'
push_force.field.use_max_distance = True
push_force.field.distance_max = 1000

# Add rigidbody to wall
bpy.context.view_layer.objects.active = wall
bpy.ops.rigidbody.object_add()
wall.rigid_body.type = 'PASSIVE'
wall.rigid_body.collision_shape = 'BOX'

# Add rigidbody to ground
bpy.context.view_layer.objects.active = ground
bpy.ops.rigidbody.object_add()
ground.rigid_body.type = 'PASSIVE'
ground.rigid_body.collision_shape = 'BOX'

# Add rigidbody to barrier parts
bpy.context.view_layer.objects.active = barrier_base
bpy.ops.rigidbody.object_add()
barrier_base.rigid_body.type = 'PASSIVE'
barrier_base.rigid_body.collision_shape = 'BOX'

bpy.context.view_layer.objects.active = barrier_backing
bpy.ops.rigidbody.object_add()
barrier_backing.rigid_body.type = 'ACTIVE'
barrier_backing.rigid_body.mass = 0.5
barrier_backing.rigid_body.collision_shape = 'BOX'
barrier_backing.rigid_body.kinematic = True  # Will be animated

bpy.context.view_layer.objects.active = barrier_impact
bpy.ops.rigidbody.object_add()
barrier_impact.rigid_body.type = 'ACTIVE'
barrier_impact.rigid_body.mass = 0.3
barrier_impact.rigid_body.collision_shape = 'CONVEX_HULL'
barrier_impact.rigid_body.kinematic = True  # Will be animated


# Add animation for the barrier compression
def animate_barrier_compression():
    # Initial position
    frame_impact = 50  # When the Sphero hits the barrier

    # Keyframe initial positions
    barrier_impact.keyframe_insert(data_path="location", frame=1)
    barrier_backing.keyframe_insert(data_path="location", frame=1)

    # Compressed position (impact phase)
    barrier_impact.location.y -= 0.5  # Move back when compressed
    barrier_impact.keyframe_insert(data_path="location", frame=frame_impact + 5)

    barrier_backing.location.y -= 0.3  # Less movement for backing
    barrier_backing.keyframe_insert(data_path="location", frame=frame_impact + 5)

    # Recovery phase (springs pushing back)
    barrier_impact.location.y += 0.4  # Not fully back to original position
    barrier_impact.keyframe_insert(data_path="location", frame=frame_impact + 15)

    barrier_backing.location.y += 0.2
    barrier_backing.keyframe_insert(data_path="location", frame=frame_impact + 15)

    # Settling phase
    barrier_impact.location.y -= 0.1
    barrier_impact.keyframe_insert(data_path="location", frame=frame_impact + 25)

    barrier_backing.location.y -= 0.05
    barrier_backing.keyframe_insert(data_path="location", frame=frame_impact + 25)

    # Final resting position
    barrier_impact.location.y += 0.05
    barrier_impact.keyframe_insert(data_path="location", frame=frame_impact + 35)

    barrier_backing.location.y += 0.02
    barrier_backing.keyframe_insert(data_path="location", frame=frame_impact + 35)

    # Add easing to make the animation more realistic
    for fcurve in barrier_impact.animation_data.action.fcurves:
        for kf in fcurve.keyframe_points:
            kf.interpolation = 'BEZIER'
            kf.handle_left_type = 'AUTO_CLAMPED'
            kf.handle_right_type = 'AUTO_CLAMPED'

    for fcurve in barrier_backing.animation_data.action.fcurves:
        for kf in fcurve.keyframe_points:
            kf.interpolation = 'BEZIER'
            kf.handle_left_type = 'AUTO_CLAMPED'
            kf.handle_right_type = 'AUTO_CLAMPED'

animate_barrier_compression()

# Add rotation to Sphero as it rolls
def animate_sphero_rotation():
    # Create an empty to control Sphero's rotation
    bpy.ops.object.empty_add(type='PLAIN_AXES', location=sphero.location)
    rotation_control = bpy.context.active_object
    rotation_control.name = "SpheroRotationControl"

    # Animate the empty's rotation
    rotation_control.keyframe_insert(data_path="rotation_euler", frame=1)

    # Full rotation around X axis (rolling forward)
    rotation_control.rotation_euler.x = 2 * math.pi * 3  # 3 complete rotations
    rotation_control.keyframe_insert(data_path="rotation_euler", frame=50)

    # Add some Y rotation to simulate slight directional changes
    rotation_control.rotation_euler.y = 0
    rotation_control.keyframe_insert(data_path="rotation_euler", frame=1)
    rotation_control.rotation_euler.y = 0.2
    rotation_control.keyframe_insert(data_path="rotation_euler", frame=20)
    rotation_control.rotation_euler.y = -0.1
    rotation_control.keyframe_insert(data_path="rotation_euler", frame=35)
    rotation_control.rotation_euler.y = 0
    rotation_control.keyframe_insert(data_path="rotation_euler", frame=50)

    # Make rotation curves smoother
    for fcurve in rotation_control.animation_data.action.fcurves:
        for kf in fcurve.keyframe_points:
            kf.interpolation = 'BEZIER'

animate_sphero_rotation()

# Animate the camera to follow the action
def animate_camera():
    # Initial position
    camera.keyframe_insert(data_path="location", frame=1)

    # Move with the Sphero
    camera.location = (10, -5, 5)
    camera.keyframe_insert(data_path="location", frame=30)

    # Position for impact
    camera.location = (5, 0, 3)
    camera.keyframe_insert(data_path="location", frame=50)

    # Pull back to see full scene
    camera.location = (8, -8, 6)
    camera.keyframe_insert(data_path="location", frame=70)

    # Smooth camera movement
    for fcurve in camera.animation_data.action.fcurves:
        for kf in fcurve.keyframe_points:
            kf.interpolation = 'BEZIER'
            kf.handle_left_type = 'AUTO_CLAMPED'
            kf.handle_right_type = 'AUTO_CLAMPED'

animate_camera()

# Add a motion blur effect for realism
scene.render.use_motion_blur = True
scene.render.motion_blur_shutter = 0.5

# Add force to the Sphero for the rebound
def add_force_field():
    bpy.ops.object.effector_add(type='FORCE', location=(0, 13, 0.75))
    force = bpy.context.active_object
    force.name = "ReboundForce"
    force.field.strength = -50  # Negative value for repulsion
    force.field.falloff_type = 'SPHERE'
    force.field.falloff_power = 2
    force.field.use_max_distance = True
    force.field.distance_max = 3

    # Animate the force field - active only during impact
    force.keyframe_insert(data_path="field.strength", frame=49)
    force.field.strength = -50
    force.keyframe_insert(data_path="field.strength", frame=50)
    force.field.strength = 0
    force.keyframe_insert(data_path="field.strength", frame=55)

add_force_field()

# Add a composite setup for better visualization
def setup_compositing():
    bpy.context.scene.use_nodes = True
    tree = bpy.context.scene.node_tree

    # Clear existing nodes
    for node in tree.nodes:
        tree.nodes.remove(node)

    # Create nodes
    render_layers = tree.nodes.new(type='CompositorNodeRLayers')
    render_layers.location = (0, 0)

    composite = tree.nodes.new(type='CompositorNodeComposite')
    composite.location = (600, 0)

    # Add color correction
    color_correction = tree.nodes.new(type='CompositorNodeColorCorrection')
    color_correction.location = (200, 0)

    # Add slight bloom effect
    glare = tree.nodes.new(type='CompositorNodeGlare')
    glare.location = (400, 0)
    glare.glare_type = 'FOG_GLOW'
    glare.quality = 'HIGH'
    glare.threshold = 0.9
    glare.size = 7

    # Connect nodes
    tree.links.new(render_layers.outputs['Image'], color_correction.inputs['Image'])
    tree.links.new(color_correction.outputs['Image'], glare.inputs['Image'])
    tree.links.new(glare.outputs['Image'], composite.inputs['Image'])

setup_compositing()

# Add text to explain what's happening in the animation
def add_explanatory_text():
    # Create a new text object
    bpy.ops.object.text_add(location=(-8, -5, 5))
    text = bpy.context.active_object
    text.name = "ExplanatoryText"
    text.data.body = "Sphero Bolt Impact Test"
    text.data.size = 0.7
    text.data.extrude = 0.05

    # Add material
    mat = bpy.data.materials.new(name="TextMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    bsdf = nodes.get("Principled BSDF")
    bsdf.inputs["Base Color"].default_value = (1.0, 1.0, 1.0, 1.0)
    bsdf.inputs["Emission"].default_value = (1.0, 1.0, 1.0, 1.0)
    bsdf.inputs["Emission Strength"].default_value = 0.5
    text.data.materials.append(mat)

    # Animate text visibility
    text.keyframe_insert(data_path="hide_render", frame=1)
    text.keyframe_insert(data_path="hide_viewport", frame=1)

    text.hide_render = True

    # Animate text to appear during impact
    text.hide_render = True
    text.hide_viewport = True
    text.keyframe_insert(data_path="hide_render", frame=1)
    text.keyframe_insert(data_path="hide_viewport", frame=1)

    text.hide_render = False
    text.hide_viewport = False
    text.keyframe_insert(data_path="hide_render", frame=45)
    text.keyframe_insert(data_path="hide_viewport", frame=45)

# Add labels to different components
def add_component_labels():
    labels = [
        ("Sphero Bolt", sphero.location + Vector((0, 0, 1.5)), 0.4),
        ("Impact Surface", barrier_impact.location + Vector((0, -1, 1.5)), 0.4),
        ("Spring System", barrier_backing.location + Vector((0, -1, 0)), 0.4),
        ("Energy Absorption Layer", barrier_backing.location + Vector((5, -1, 0)), 0.4),
        ("Stable Base", barrier_base.location + Vector((0, -1, -1)), 0.4),
        ("Wall", wall.location + Vector((0, -1, 0)), 0.4)
    ]

    label_objects = []
    for text_content, location, size in labels:
        bpy.ops.object.text_add(location=location)
        label = bpy.context.active_object
        label.name = f"Label_{text_content}"
        label.data.body = text_content
        label.data.size = size
        label.data.align_x = 'CENTER'

        # Add material
        mat = bpy.data.materials.new(name=f"LabelMaterial_{text_content}")
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        bsdf = nodes.get("Principled BSDF")

        # Add material
        mat = bpy.data.materials.new(name=f"LabelMaterial_{text_content}")
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        bsdf = nodes.get("Principled BSDF")
        bsdf.inputs["Base Color"].default_value = (1.0, 1.0, 1.0, 1.0)
        bsdf.inputs["Emission"].default_value = (1.0, 1.0, 1.0, 1.0)
        bsdf.inputs["Emission Strength"].default_value = 1.0
        label.data.materials.append(mat)

        label_objects.append(label)

    return label_objects

# Call the functions to add explanatory text and labels
add_explanatory_text()
add_component_labels()

# Set output path and render
scene.render.image_settings.file_format = 'FFMPEG'
scene.render.ffmpeg.format = 'MPEG4'
scene.render.filepath = "/content/drive/MyDrive/SpheroRender/sphero_impact_test.mp4"

# Render the animation
#bpy.ops.render.render(animation=True)

import bpy
import csv
import os
import math
from mathutils import Vector

# Configuration
scene = bpy.context.scene
fps = scene.render.fps
dt = 1.0 / fps # Time step between frames
mass = 0.5 # kg (mass of Sphero)
g = 9.81 # m/s²
log_file = "/content/drive/MyDrive/SpheroRender/sphero_physics_log.csv"

# Ensure the output directory exists
os.makedirs(os.path.dirname(log_file), exist_ok=True)

# Enhanced data collection class
class PhysicsDataCollector:
    def __init__(self, object_name, mass=0.5):
        self.obj = bpy.data.objects.get(object_name)
        if not self.obj:
            raise ValueError(f"Object '{object_name}' not found!")
            
        self.mass = mass
        self.frame_history = {} # Store data for each frame
        self.start_frame = None
        self.impact_frame = None
        self.impact_detected = False
        self.max_displacement = 0
        self.start_pos = None
        self.prev_dir = None
        
        # Initialize CSV file
        with open(log_file, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([
                'Frame', 'Time(s)', 
                'Position_X', 'Position_Y', 'Position_Z',
                'Velocity_X', 'Velocity_Y', 'Velocity_Z', 'Speed',
                'Acceleration_X', 'Acceleration_Y', 'Acceleration_Z', 'Acceleration_Magnitude',
                'Force_X', 'Force_Y', 'Force_Z', 'Force_Magnitude',
                'Momentum_X', 'Momentum_Y', 'Momentum_Z', 'Momentum_Magnitude',
                'Kinetic_Energy', 'Potential_Energy', 'Total_Energy',
                'Impact_Displacement', 'Rebound_Velocity',
                'Event'
            ])
    
    def get_velocity(self, frame):
        """Get velocity from Blender physics if available, or calculate from positions"""
        if hasattr(self.obj, 'rigid_body') and self.obj.rigid_body:
            # Try to get velocity directly from rigid body simulation
            try:
                # Need to ensure the simulation is evaluated at this frame
                scene = bpy.context.scene
                scene.frame_set(frame)
                bpy.context.view_layer.update()
                
                # Get velocity from rigid body if available
                if hasattr(self.obj.rigid_body, 'linear_velocity'):
                    return Vector(self.obj.rigid_body.linear_velocity)
            except:
                pass # Fall back to position-based calculation
        
        # Calculate velocity from position differences as fallback
        if frame > scene.frame_start:
            prev_frame = frame - 1
            if prev_frame in self.frame_history:
                curr_pos = self.obj.location.copy()
                prev_pos = self.frame_history[prev_frame]['position']
                return (curr_pos - prev_pos) / dt
        
        # Default velocity if we can't calculate it yet
        return Vector((0, 0, 0))
    
    def get_acceleration(self, frame, velocity):
        """Calculate acceleration from velocity changes"""
        if frame > scene.frame_start + 1:
            prev_frame = frame - 1
            if prev_frame in self.frame_history:
                prev_vel = self.frame_history[prev_frame]['velocity']
                return (velocity - prev_vel) / dt
        
        return Vector((0, 0, 0))
    
    def detect_impact(self, frame, velocity, acceleration):
        """Detect impact events based on velocity and acceleration changes"""
        # Initialize event string
        event = ""
        
        # Get acceleration magnitude
        accel_magnitude = acceleration.length
        
        # Get current direction (simplified to just y component for our example)
        current_dir = 1 if velocity.y > 0 else -1
        
        # Detect impact through several methods
        if frame > scene.frame_start + 1:
            prev_frame = frame - 1
            if prev_frame in self.frame_history:
                prev_vel = self.frame_history[prev_frame]['velocity']
                
                # Method 1: High acceleration spike
                if accel_magnitude > 30: # Threshold determined experimentally
                    if not self.impact_detected:
                        self.impact_detected = True
                        self.impact_frame = frame
                        event = "IMPACT-ACCELERATION"
                
                # Method 2: Direction reversal
                if self.prev_dir is not None and current_dir != self.prev_dir:
                    if not self.impact_detected or frame > self.impact_frame + 10: # Allow new impacts after some frames
                        self.impact_detected = True
                        self.impact_frame = frame
                        event = "IMPACT-DIRECTION"
                
                # Method 3: Sudden velocity drop
                prev_speed = prev_vel.length
                curr_speed = velocity.length
                if prev_speed > 2 and curr_speed < prev_speed * 0.5: # Speed dropped by more than 50%
                    if not self.impact_detected or frame > self.impact_frame + 10:
                        self.impact_detected = True
                        self.impact_frame = frame
                        event = "IMPACT-VELOCITY"
        
        # Update direction for next frame
        self.prev_dir = current_dir
        
        return event
    
    def calculate_displacement(self, position):
        """Calculate displacement from start position"""
        if self.start_pos is None:
            self.start_pos = position.copy()
            return 0
        
        displacement_vector = position - self.start_pos
        return displacement_vector.length
    
    def calculate_energies(self, velocity, position):
        """Calculate kinetic and potential energies"""
        # Kinetic energy: 1/2 * m * v²
        speed = velocity.length
        KE = 0.5 * self.mass * speed ** 2
        
        # Potential energy: m * g * h (relative to starting height)
        height = position.z
        if self.start_pos:
            height -= self.start_pos.z
        PE = self.mass * g * height
        
        return KE, PE
    
    def process_frame(self, frame):
        """Process and log physics data for a single frame"""
        scene = bpy.context.scene
        scene.frame_set(frame)
        bpy.context.view_layer.update()
        
        if self.start_frame is None:
            self.start_frame = frame
        
        # Calculate time in seconds
        time = (frame - scene.frame_start) * dt
        
        # Get current position
        position = self.obj.location.copy()
        
        # Calculate velocity
        velocity = self.get_velocity(frame)
        speed = velocity.length
        
        # Calculate acceleration
        acceleration = self.get_acceleration(frame, velocity)
        accel_magnitude = acceleration.length
        
        # Calculate force (F = ma)
        force = acceleration * self.mass
        force_magnitude = force.length
        
        # Calculate momentum (p = mv)
        momentum = velocity * self.mass
        momentum_magnitude = momentum.length
        
        # Calculate displacement from start
        displacement = self.calculate_displacement(position)
        
        # Calculate energy
        KE, PE = self.calculate_energies(velocity, position)
        total_energy = KE + PE
        
        # Track maximum displacement for rebound analysis
        if displacement > self.max_displacement:
            self.max_displacement = displacement
        
        # Detect impact events
        event = self.detect_impact(frame, velocity, acceleration)
        
        # Calculate rebound velocity (only meaningful after impact)
        rebound_velocity = 0
        if self.impact_detected and frame > self.impact_frame:
            # Simple definition: speed after impact
            rebound_velocity = speed
        
        # Calculate impact displacement (how far object has compressed)
        impact_displacement = 0
        if self.impact_detected:
            impact_pos = self.frame_history.get(self.impact_frame, {}).get('position')
            if impact_pos:
                impact_displacement = (impact_pos - position).length
        
        # Store frame data in history
        self.frame_history[frame] = {
            'position': position.copy(),
            'velocity': velocity.copy(),
            'acceleration': acceleration.copy(),
            'event': event
        }
        
        # Log data to CSV
        with open(log_file, 'a', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([
                frame, round(time, 4),
                round(position.x, 4), round(position.y, 4), round(position.z, 4),
                round(velocity.x, 4), round(velocity.y, 4), round(velocity.z, 4), round(speed, 4),
                round(acceleration.x, 4), round(acceleration.y, 4), round(acceleration.z, 4), round(accel_magnitude, 4),
                round(force.x, 4), round(force.y, 4), round(force.z, 4), round(force_magnitude, 4),
                round(momentum.x, 4), round(momentum.y, 4), round(momentum.z, 4), round(momentum_magnitude, 4),
                round(KE, 4), round(PE, 4), round(total_energy, 4),
                round(impact_displacement, 4), round(rebound_velocity, 4),
                event
            ])

# Main execution function
def main():
    # Create physics data collector for Sphero
    try:
        sphero_collector = PhysicsDataCollector('Sphero', mass=0.5)
        
        # Process each frame
        for frame in range(scene.frame_start, scene.frame_end + 1):
            sphero_collector.process_frame(frame)
            
            # Print progress
            if frame % 10 == 0:
                print(f"Processed frame {frame}/{scene.frame_end}")
                
        print(f"Physics data logged to {log_file}")
        
    except Exception as e:
        print(f"Error: {e}")

# Make sure to bake physics and run the data collection
bpy.ops.ptcache.bake_all(bake=True)
main()

!blender -b -P /content/sphero_animation.py

!ls -la /content/drive/MyDrive/SpheroRender/